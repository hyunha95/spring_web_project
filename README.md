# spring_web_project

src/main/resources: 실행할 때 참고하는 기본 경로(주로 설정 파일들을 넣는다)   
servlet-context.xml: 웹과 관련된 스프링 설정 파일   
web.xml: Tomcat의 web.xml파일   
pom.xml: Maven이 사용하는 pom.xml   
root-context.xml: 스프링 프레임워크에서 관리해야 하는 객체(Bean)를 설정하는 파일. 스프링에서 root-context.xml은 스프링이 로딩되면서 읽어 들이는 문서이므로, 주로 이미 만들어진 클래스들을 이용해서 스프링의 빈(Bean)으로 등록할 때 사용된다.   

경량 프레임워크(light-weight Framework): 과거 J2EE 기술은 너무나 복잡하고 방대했기 때문에, 특정 기능을 위주로 간단한 jar파일 등을 이용해서 모든 개발이 가능하도록 구성된 프레임워크      
스프링의 주요특징
-----------------
* POJO(Plain Old Java Project) 기반의 구성: 내부에는 객체 간의 관계를 구성할 수 있는 특징을 가지고 있다. 스프링은 다른 프레임워크들과 달리 이 관계를 구성할 때 별도의 API 등을 사용하지 않는 POJO의 구성만으로 가능하도록 제작되어 있다. 일반적인 Java 코드를 이용해서 객체를 구성하는 방식을 그대로 스프링에서 사용할 수 있다.
* 의존성 주입(DI)을 통한 객체 간의 관계 구성: 의존성(Dependency)이라는 것은 하나의 객체가 다른 객체 없이 제대로 된 역할을 할 수 없다는 것을 의미한다. 의존성은 하나의 객체가 다른 객체의 상태에 따라 영향을 받는 것을 의미한다. 주입을 받는 입상에서는 어떤 객체인지 신경 쓸 필요가 없다. 어떤 객체에 의존하든 자신의 역할은 변하지 않는다. 스프링에서는 'ApplicationContext'라는 존재가 필요한 객체들을 생성하고, 필요한 객체들을 주입하는 역할을 해 주는 구조이다. 스프링을 이용하면 개발자들은 기존의 프로그래밍과 달리 객체와 객체를 분리해서 생성하고, 이러한 객체들을 엮는(wiring) 작업을 하는 형태의 개발을 하게 된다. 스프링에서는 ApplicationContext가 관리하는 객체들을 '빈(Bean)'이라는 용어로 부르고, 빈과 빈 사이의 의존관계를 처리하는 방식으로 XML 설정, 어노테이션 설정, Java 설정 방식을 이용할 수 있다.
* AOP(Aspect-Oriented-Programming) 지원: 대부분의 시스템이 공통으로 가지고 있는 보안이나 로그, 트랜잭션과 같이 비즈니스 로직은 아니지만, 반드시 처리가 필요한 부분을 스프링에서는 '횡단 관심사'라고 한다. 스프링은 이러한 횡단 관심사를 분리해서 제작하는 것이 가능하다. AOP는 이러한 횡단 관심사를 모듈로 분리하는 프로그래밍의 패러다임이다.
* 편리한 MVC 구조
* WAS에 종속적이지 않은 개발 환경   

스프링에서 관리하는 객체를 빈(Bean)이라고 한다.   
@Component: 스프링에게 해당 클래스가 스프링에서 관리해야 하는 대상임을 표시하는 어노테이션   

스프링이 동작하면서 생기는 일
-----------------------
1. 스프링 프레임워크가 시작되면 먼저 스프링이 사용하는 메모리 영역을 만들게 되는데 이를 컨텍스트(Context)라고 한다. 스프링에서는 ApplicationContext라는 이름의 객체가 만들어진다.
2. 스프링은 자신이 객체를 생성하고 관리해야 하는 객체들에 대한 설정이 필요하다. 이에 대한 설정이 root-context.xml 파일이다.
3. root-context.xml에 설정되어 있는 <context:component-scan> 태그의 내용을 통해서 'org.zerock.sample' 패키지를 스캔(scan)하기 시작한다.
4. 해당 패키지에 있는 클래스들 중에서 스프링이 사용하는 @Component라는 어노테이션이 존재하는 클래스의 인스턴스를 생성한다.
5. Restaurant 객체는 Chef객체가 필요하다는 어노테이션(@Autowired) 설정이 있으므로, 스프링은 Chef 객체의 레퍼런스를 Restaurant 객체에 주입한다.   

JUnit
----
현재 테스트 코드가 스프링을 실행하는 역할을 할 것이라는 것을 @RunWith 어노테이션으로 표시한다.   
@ContextConfiguration은 지정된 클래스나 문자열을 이용해서 필요한 객체들을 스프링 내에 객체로 등록하게 된다.   
@Log4j는 Lombok을 이용해서 로그를 기록하는 Logger를 변수로 생성한다.   
@Autowired는 해당 인스턴스 변수를 스프링으로부터 자동으로 주입해 달하는 표시이다.   
@Test는 JUnit에서 테스트 대상을 표시하는 어노테이션이다.   
assertNotNull()은 해당 변수가 null이 아니어야만 테스트가 성공한다는 것을 의미한다.   

'Spring Legacy Project'로 생성한 경우에는 기본적으로 Log4j 설정이 있기 때문에 추가적인 설정 없이 @Log4j만으로 로그 객체를 준비할 수 있다.   
@Component는 해당 클래스가 스프링에서 객체로 만들어서 관리하는 대상임을 명시하는 어노테이션이다.   
@Autowired는 스프링 내부에서 자신이 특정한 객체에 의존적이므로 자신에게 해당 타입의 빈을 주입해주라는 표시이다. 스프링은 @Autowired 어노테이션을 보고 스프링 내부에 관리되는 객체(들) 중에 적당한 것이 있는지를 확인하고, 자동으로 주입해 준다.
@ContextConfiguration은 스프링이 실행되면서 어떤 설정 정보를 읽어 들어야 하는지 명시한다. 속성으로는 locations를 이용해서 문자열의 배열로 XML 설정 파일을 명시할 수도 있고, classes 속성으로 @Configuration이 적용된 클래스를 지정해 줄 수도 있다.   
@RunWith는 테스트 시 필요한 클래스를 지정한다. 스프링은 SpringJUnit4ClassRunner 클래스가 대상이 된다.   
@Test는 JUnit에서 해당 메서드가 JUint 상에서 단위 테스트의 대상인지 알려준다.   
@AllArgsConstructor는 인스턴스 변수로 선언된 모든 것을 파라미터로 받는 생성자를 작성하게 된다.   
@RequiredArgsConstructor는 @NonNull이나 final이 붙은 인스턴스 변수에 대한 생성자를 만들어 낸다.
@Bean은 XML설정에서 <bean> 태그와 동일한 역할을 한다고 생각하면 된다. @Bean이 선언된 메서드의 실행 결과로 반환된 객체는 스프링의 객체로 등록된다.   

Mapper
--------------
XML 매퍼를 이용할 때 신경 써야 하는 부분은 <mapper> 태그의 namespace 속성값이다. MyBatis는 Mapper 인터페이스와 XML을 인터페이스의 이름과 namespace 속성값을 가지고 판단한다.   
<select> 태그의 id 속성값은 메서드의 이름과 동일하게 맞춰야 한다. <select> 태그의 경우 resultType 속성을 가지는데 이 값은 인터페이스에 선언된 메서드의 리턴 타입과 동일하게 작성한다.















